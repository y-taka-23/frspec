module io.cheshirecat.FRSpec where

import frege.control.monad.trans.MonadIO ( MonadIO, liftIO )
import frege.data.Monoid ( Monoid, mappend )
import frege.java.Lang ( System.exit )

-- type stabs
type FilePath = String
type Args = () -- Defined in QuichCheck
type Arg e = () -- inner type of Example

type SpecWith a = SpecM a ()

type ActionWith a = a -> IO ()

data Tree c a =
      Node String [Tree a c]
    | NodeWithCleanup c [Tree c a]
    | Leaf a

--instance Functor (Tree c) where
--instance Foldable (Tree c) where
--instance Traversable (Tree c) where

data Params = Params
    { paramsQuickCheckArgs  :: Args
    , paramsSmallCheckDepth :: Int
    }

--instance Show Params where

type Progress = (Int, Int)

type ProgressCallback = Progress -> IO ()

data LocationAccuracy =
      ExactLocation
    | BestEffort

--instance Eq LocationAccuracy
--instance Read LocationAccuracy
--instance Show LocationAccuracy

data Location = Location
    { locationFile     :: FilePath
    , locationLine     :: Int
    , locationColumn   :: Int
    , locationAccuracy :: LocationAccuracy
    }

--instance Eq Location where
--instance Read Location where
--instance Show Location where

data Result =
      Success
    | Pending (Maybe String)
    | Fail (Maybe Location) String

--instance Eq Result where
--instance Read Result where
--instance Show Result where
--instance Exception Result where
--instance Example Result where
--type Arg Result

data Item a = Item
    { itemRequirement      :: String
    , itemLocation         :: Maybe Location
    , itemIsParallelizable :: Bool
    , itemExample          :: Params -> (ActionWith a -> IO ()) ->
                              ProgressCallback -> IO Result
    }

type SpecTree a = Tree (ActionWith a) (Item a)

data SpecM a r = SpecM (WriterT [SpecTree a] IO r)

runSpecM :: SpecWith a -> IO [SpecTree a]
runSpecM (SpecM spec) = execWriterT spec

instance Functor (SpecM a) where
    fmap f (SpecM spec) = SpecM $ fmap f spec

instance Applicative (SpecM a) where
    pure = SpecM . pure
    (<*>) (SpecM f) (SpecM v) = SpecM $ f <*> v

instance Monad (SpecM a) where
    pure = Applicative.pure
    (>>=) (SpecM m) k = SpecM $ m >>= unSpecM . k
        where unSpecM (SpecM x) = x

describe :: String -> SpecWith a -> SpecWith a
describe label spec =
    runIO (runSpecM spec) >>= fromSpecList . return . specGroup label

runIO :: IO r -> SpecM a r
runIO = SpecM . liftIO

class Example e where
    evaluateExample :: e -> Params -> (ActionWith (Arg e) -> IO ()) ->
                       ProgressCallback -> IO Result
--    type Arg e

--instance Example Bool where
--instance Example Property where
--instance Example Result where

instance Example Expectation where
    evaluateExample e _ _ _ = undefined

--instance Example (a -> Expectation) where
--instance Example (a -> Property) where

--it :: (?loc :: CallStack, Example a) => String -> a -> SpecWith (Arg a)
it :: (Example a) => String -> a -> SpecWith (Arg a)
it label action = fromSpecList [ specItem label action ]

fromSpecList :: [SpecTree a] -> SpecWith a
fromSpecList = SpecM . tell

--specItem :: (?loc :: CallStack, Example a) => String -> a -> SpecTree (Arg a)
specItem :: (Example a) => String -> a -> SpecTree (Arg a)
specItem s e = Leaf $ Item requirement Nothing false e.evaluateExample
    where
        requirement
            | null s    = "(unspecified behavior)"
            | otherwise = s

specGroup :: String -> [SpecTree a] -> SpecTree a
specGroup = undefined

type Spec = SpecWith ()

hspec :: Spec -> IO ()
hspec = hspecWith defaultConfig

hspecWith :: Config -> Spec -> IO ()
hspecWith conf spec = do
    r <- hspecWithResult conf spec
    unless (isSuccess r) exitFailure

-- TODO: In v3.23, exitFailure have not merged...
exitFailure :: IO ()
exitFailure = System.exit 1

data Config = Config
    { configNested     :: Bool
    , configFormatter  :: Maybe String
    , configNoMain     :: Bool
    , configModuleName :: Maybe Bool
    }
derive Eq   Config
derive Show Config

defaultConfig :: Config
defaultConfig = Config false Nothing false Nothing

data Summary = Summary
    { summaryExamples :: Int
    , summaryFailures :: Int
    }
derive Eq   Summary
derive Show Summary

isSuccess :: Summary -> Bool
isSuccess summary = summary.summaryFailures == 0

hspecWithResult :: Config -> Spec -> IO Summary
hspecWithResult = undefined

---------- in hspec-expectations -----------------

type Expectation = Assertion

--shouldBe :: (?loc :: CallStack, Show a, Eq a) => a -> a -> Expectation
shouldBe :: (Show a, Eq a) => a -> a -> Expectation
actual `shouldBe` expected = expectTrue
    ("expected: " ++ show expected ++ "\n but got: " ++ show actual)
    (actual == expected)
infix 1 shouldBe

--expectTrue :: (?loc :: CallStack) => String -> Bool -> Expectation
expectTrue :: String -> Bool -> Expectation
expectTrue msg b = unless b (expectationFailure msg)

--expectationFailure :: (?loc :: CallStack) => String -> Expectation
expectationFailure :: String -> Expectation
expectationFailure = assertFailure

---------- in HUnit -----------------

type Assertion = IO ()

--(?loc :: CallStack) => String -> Assertion
assertFailure :: String -> Assertion
assertFailure msg = msg `deepseq` throwIO (HUnitFailure.new msg)

---------- others -----------------

--TODO: Is there an more better exception than IAE?
data HUnitFailure = pure native java.lang.IllegalArgumentException where
    pure native new :: String -> HUnitFailure

--TODO: the original deepseq evaluate the 1st arg strictly
--deepseq :: (NFData a) => a -> b -> b
deepseq _ = id

--TODO: using StateT transformer is better?
-- Frege doesn't have the Writer monad
data WriterT w m a = WriterT { run :: m (a, w) }

mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
mapWriterT f m = WriterT $ f m.run

instance (Functor m) => Functor (WriterT w m) where
    fmap f = mapWriterT $ fmap $ \(x, w) -> (f x, w)

instance (Monoid w, Applicative m) => Applicative (WriterT w m) where
    pure x = WriterT $ pure (x, mempty)
    (<*>) f v = WriterT $ liftA2 k f.run v.run
        where
            k (g, w) (x, w') = (g x, w `mappend` w')

instance (Monoid w, Monad m) => Monad (WriterT w m) where
    pure = Applicative.pure
    (>>=) m k = WriterT $ do
        (x, w)  <- m.run
        (y, w') <- (k x).run
        return (y, w `mappend` w')

instance (Monoid w, Monad m) => MonadIO (WriterT w m) where
    liftIO = undefined

execWriterT :: (Monad m) => WriterT w m a -> m w
execWriterT m = do
    (_, w) <- m.run
    return w

writer :: (Monad m) => (a, w) -> WriterT w m a
writer = WriterT . return

tell :: (Monoid w, Monad m) => w -> WriterT w m ()
tell x = writer ((), x)


main = hspec $ do
    describe "Prelude.head" $ do
        it "returns the first element of a list" $ do
            head [23 ..] `shouldBe` 23
